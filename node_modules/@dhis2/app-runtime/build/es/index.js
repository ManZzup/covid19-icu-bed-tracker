import React, { useRef, useState, useEffect, useCallback, useContext } from 'react';

const getMutationFetchType = mutation => mutation.type === 'update' ? mutation.partial ? 'update' : 'replace' : mutation.type;

const resolveDynamicQuery = ({
  resource,
  id,
  data,
  params
}, variables) => ({
  resource,
  id: typeof id === 'function' ? id(variables) : id,
  data: typeof data === 'function' ? data(variables) : data,
  params: typeof params === 'function' ? params(variables) : params
});

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

class InvalidQueryError extends Error {
  constructor(errors) {
    super(`Invalid query\n${errors.map(e => ' - ' + e).join('\n')}`);

    _defineProperty(this, "type", 'invalid-query');

    _defineProperty(this, "details", void 0);

    this.details = errors;
  }

}

const validQueryKeys = ['resource', 'id', 'params', 'data'];
const validTypes = ['read', 'create', 'update', 'replace', 'delete'];
const getResourceQueryErrors = (type, query) => {
  if (!validTypes.includes(type)) {
    return [`Unknown query or mutation type ${type}`];
  }

  if (typeof query !== 'object') {
    return ['A query or mutation must be a javascript object'];
  }

  const errors = [];

  if (!query.resource || typeof query.resource !== 'string') {
    errors.push('Property resource must be a string');
  }

  if (type === 'create' && query.id) {
    errors.push("Mutation type 'create' does not support property 'id'");
  }

  if (query.id && typeof query.id !== 'string') {
    errors.push('Property id must be a string');
  }

  if (query.params && typeof query.params !== 'object') {
    errors.push('Property params must be an object');
  }

  if (type === 'delete' && query.data) {
    errors.push("Mutation type 'delete' does not support property 'data'");
  }

  const invalidKeys = Object.keys(query).filter(k => !validQueryKeys.includes(k));
  invalidKeys.forEach(k => {
    errors.push(`Property ${k} is not supported`);
  });
  return errors;
};
const validateResourceQueries = (queries, names = []) => {
  if (names.length !== queries.length) {
    for (let i = names.length; i < queries.length; ++i) {
      names.push('query#' + i);
    }
  }

  const errors = queries.reduce((errors, query, i) => errors.concat(getResourceQueryErrors('read', query).map(e => `[${names[i]}] ${e}`)), []);

  if (errors.length) {
    throw new InvalidQueryError(errors);
  }
};
const validateResourceQuery = (type, query) => {
  const errors = getResourceQueryErrors(type, query);

  if (errors.length) {
    throw new InvalidQueryError(errors);
  }
};

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

const reduceResponses = (responses, names) => responses.reduce((out, response, idx) => {
  out[names[idx]] = response;
  return out;
}, {});

class DataEngine {
  constructor(link) {
    _defineProperty$1(this, "link", void 0);

    this.link = link;
  }

  query(query, {
    variables = {},
    signal,
    onComplete,
    onError
  } = {}) {
    const names = Object.keys(query);
    const queries = names.map(name => query[name]).map(q => resolveDynamicQuery(q, variables));
    validateResourceQueries(queries, names);
    return Promise.all(queries.map(q => {
      return this.link.executeResourceQuery('read', q, {
        signal
      });
    })).then(results => {
      const data = reduceResponses(results, names);
      onComplete && onComplete(data);
      return data;
    }).catch(error => {
      onError && onError(error);
      throw error;
    });
  }

  mutate(mutation, {
    variables = {},
    signal,
    onComplete,
    onError
  } = {}) {
    const query = resolveDynamicQuery(mutation, variables);
    const type = getMutationFetchType(mutation);
    validateResourceQuery(type, query);
    const result = this.link.executeResourceQuery(type, query, {
      signal
    });
    return result.then(data => {
      onComplete && onComplete(data);
      return data;
    }).catch(error => {
      onError && onError(error);
      throw error;
    });
  }

}

function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

class FetchError extends Error {
  constructor({
    message,
    type,
    details
  }) {
    super(message);

    _defineProperty$2(this, "type", void 0);

    _defineProperty$2(this, "details", void 0);

    this.type = type;
    this.details = details;
  }

}

function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

class CustomDataLink {
  constructor(customData, {
    failOnMiss = true,
    loadForever = false
  } = {}) {
    _defineProperty$3(this, "failOnMiss", void 0);

    _defineProperty$3(this, "loadForever", void 0);

    _defineProperty$3(this, "data", void 0);

    this.data = customData;
    this.failOnMiss = failOnMiss;
    this.loadForever = loadForever;
  }

  async executeResourceQuery(type, query, options) {
    if (this.loadForever) {
      return new Promise(() => {});
    }

    const customResource = this.data[query.resource];

    if (!customResource) {
      if (this.failOnMiss) {
        throw new Error(`No data provided for resource type ${query.resource}!`);
      }

      return Promise.resolve(null);
    }

    switch (typeof customResource) {
      case 'string':
      case 'number':
      case 'boolean':
      case 'object':
        return customResource;

      case 'function':
        const result = await customResource(type, query, options);

        if (typeof result === 'undefined' && this.failOnMiss) {
          throw new Error(`The custom function for resource ${query.resource} must always return a value but returned ${result}`);
        }

        return result || null;
    }
  }

}

function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

class ErrorLink {
  constructor(errorMessage) {
    _defineProperty$4(this, "errorMessage", void 0);

    this.errorMessage = errorMessage;
  }

  executeResourceQuery() {
    console.error(this.errorMessage);
    return Promise.reject(this.errorMessage);
  }

}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty$5(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty$5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
const parseContentType = contentType => {
  return contentType ? contentType.split(';')[0].trim().toLowerCase() : null;
};
const parseStatus = async response => {
  if (response.status === 401 || response.status === 403 || response.status === 409) {
    const message = await response.json().then(body => {
      return body.message;
    }).catch(() => {
      return response.status === 401 ? 'Unauthorized' : 'Forbidden';
    });
    throw new FetchError({
      type: 'access',
      message,
      details: response
    });
  }

  if (response.status < 200 || response.status >= 400) {
    throw new FetchError({
      type: 'unknown',
      message: `An unknown error occurred - ${response.statusText} (${response.status})`,
      details: response
    });
  }

  return response;
};
function fetchData(url, options = {}) {
  return fetch(url, _objectSpread({}, options, {
    credentials: 'include',
    headers: _objectSpread({
      'X-Requested-With': 'XMLHttpRequest',
      Accept: 'application/json'
    }, options.headers)
  })).catch(err => {
    throw new FetchError({
      type: 'network',
      message: 'An unknown network error occurred',
      details: err
    });
  }).then(parseStatus).then(async response => {
    if (parseContentType(response.headers.get('Content-Type')) === 'application/json') {
      return await response.json(); // Will throw if invalid JSON!
    }

    return await response.text();
  });
}

const joinPath = (...parts) => {
  const realParts = parts.filter(part => !!part);
  return realParts.map(part => part.replace(/^\/+|\/+$/g, '')).join('/');
};

const getMethod = type => {
  switch (type) {
    case 'create':
      return 'POST';

    case 'read':
      return 'GET';

    case 'update':
      return 'PATCH';

    case 'replace':
      return 'PUT';

    case 'delete':
      return 'DELETE';
  }
};

const queryToRequestOptions = (type, {
  data
}, signal) => ({
  method: getMethod(type),
  body: data ? JSON.stringify(data) : undefined,
  headers: data ? {
    'Content-Type': 'application/json'
  } : undefined,
  signal
});

const encodeQueryParameter = param => {
  if (Array.isArray(param)) {
    return param.map(encodeQueryParameter).join(',');
  }

  if (typeof param === 'string') {
    return encodeURIComponent(param);
  }

  if (typeof param === 'number') {
    return String(param);
  }

  if (typeof param === 'object') {
    throw new Error('Object parameter mappings not yet implemented');
  }

  throw new Error('Unknown parameter type');
};

const queryParametersToQueryString = params => Object.keys(params).filter(key => key && params[key]).map(key => `${encodeURIComponent(key)}=${encodeQueryParameter(params[key])}`).join('&');

const actionPrefix = 'action::';

const isAction = resource => resource.startsWith(actionPrefix);

const makeActionPath = resource => joinPath('dhis-web-commons', `${resource.substr(actionPrefix.length)}.action`);

const queryToResourcePath = (apiPath, {
  resource,
  id,
  params = {}
}) => {
  const base = isAction(resource) ? makeActionPath(resource) : joinPath(apiPath, resource, id);

  if (Object.keys(params).length) {
    return `${base}?${queryParametersToQueryString(params)}`;
  }

  return base;
};

function _defineProperty$6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
class RestAPILink {
  constructor({
    baseUrl,
    apiVersion
  }) {
    _defineProperty$6(this, "apiPath", void 0);

    _defineProperty$6(this, "baseUrl", void 0);

    _defineProperty$6(this, "apiVersion", void 0);

    this.baseUrl = baseUrl;
    this.apiVersion = apiVersion;
    this.apiPath = joinPath('api', String(apiVersion));
  }

  fetch(path, options) {
    return fetchData(joinPath(this.baseUrl, path), options);
  }

  executeResourceQuery(type, query, {
    signal
  }) {
    return this.fetch(queryToResourcePath(this.apiPath, query), queryToRequestOptions(type, query, signal));
  }

}

const errorMessage = 'DHIS2 data context must be initialized, please ensure that you include a <DataProvider> in your application';
const link = new ErrorLink(errorMessage);
const engine = new DataEngine(link);
const defaultContext = {
  engine
};

const DataContext = React.createContext(defaultContext);

const CustomDataProvider = ({
  children,
  data,
  options
}) => {
  const link = new CustomDataLink(data, options);
  const engine = new DataEngine(link);
  const context = {
    engine
  };
  return React.createElement(DataContext.Provider, {
    value: context
  }, children);
};

const useStaticInput = (staticValue, {
  warn = false,
  name = 'input'
} = {}) => {
  const originalValue = useRef(staticValue);
  const [value, setValue] = useState(() => originalValue.current);
  useEffect(() => {
    if (warn && originalValue.current !== staticValue) {
      console.warn(`The ${name} should be static, don't create it within the render loop!`);
    }
  }, [warn, staticValue, originalValue, name]);
  return [value, setValue];
};

function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function (key) {
        _defineProperty$7(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty$7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
const useQueryExecutor = ({
  execute,
  variables: initialVariables,
  singular,
  immediate,
  onComplete,
  onError
}) => {
  const [theExecute] = useStaticInput(execute);
  const [state, setState] = useState({
    called: !!immediate,
    loading: !!immediate
  });
  const variables = useRef(initialVariables);
  const abortControllersRef = useRef([]);
  const abort = useCallback(() => {
    abortControllersRef.current.forEach(controller => controller.abort());
    abortControllersRef.current = [];
  }, []);
  const manualAbort = useCallback(() => {
    abort();
    setState(state => ({
      called: state.called,
      loading: false,
      error: new FetchError({
        type: 'aborted',
        message: 'Aborted'
      })
    }));
  }, [abort]);
  const refetch = useCallback((newVariables = {}) => {
    setState(state => !state.called || !state.loading ? {
      called: true,
      loading: true
    } : state);

    if (singular) {
      abort(); // Cleanup any in-progress fetches
    }

    const controller = new AbortController();
    abortControllersRef.current.push(controller);
    variables.current = _objectSpread$1({}, variables.current, {}, newVariables);
    const options = {
      variables: variables.current,
      signal: controller.signal,
      onComplete,
      onError
    };
    return theExecute(options).then(data => {
      if (!controller.signal.aborted) {
        setState({
          called: true,
          loading: false,
          data
        });
        return data;
      }

      return new Promise(() => {});
    }).catch(error => {
      if (!controller.signal.aborted) {
        setState({
          called: true,
          loading: false,
          error
        });
      }

      return new Promise(() => {}); // Don't throw errors in refetch promises, wait forever
    });
  }, [abort, onComplete, onError, singular, theExecute]); // Don't include immediate or refetch as deps, otherwise unintentional refetches
  // may be triggered by changes to input, i.e. recreating the onComplete callback

  useEffect(() => {
    if (immediate) {
      refetch();
    }

    return abort;
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  return _objectSpread$1({
    refetch,
    abort: manualAbort
  }, state);
};

const useDataEngine = () => {
  const context = useContext(DataContext);
  return context.engine;
};

const empty = {};
const useDataMutation = (mutation, {
  onComplete,
  onError,
  variables = empty,
  lazy = true
} = {}) => {
  const engine = useDataEngine();
  const [theMutation] = useStaticInput(mutation, {
    warn: true,
    name: 'mutation'
  });
  const execute = useCallback(options => engine.mutate(theMutation, options), [engine, theMutation]);
  const {
    refetch: mutate,
    called,
    loading,
    error,
    data
  } = useQueryExecutor({
    execute,
    variables,
    singular: false,
    immediate: !lazy,
    onComplete,
    onError
  });
  return [mutate, {
    engine,
    called,
    loading,
    error,
    data
  }];
};

const DataMutation = ({
  mutation,
  onComplete,
  onError,
  variables,
  children
}) => {
  const mutationState = useDataMutation(mutation, {
    onComplete,
    onError,
    variables
  });
  return children(mutationState);
};

const ConfigContext = React.createContext({
  baseUrl: '..',
  apiVersion: 32
});

const useConfig = () => useContext(ConfigContext);

const makeContext = config => config;

const ConfigProvider = ({
  config,
  children
}) => React.createElement(ConfigContext.Provider, {
  value: makeContext(config)
}, children);

function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys$2(Object(source), true).forEach(function (key) {
        _defineProperty$8(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty$8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
const DataProvider = props => {
  const config = _objectSpread$2({}, useConfig(), {}, props);

  const link = new RestAPILink(config);
  const engine = new DataEngine(link);
  const context = {
    engine
  };
  return React.createElement(DataContext.Provider, {
    value: context
  }, props.children);
};

const empty$1 = {};
const useDataQuery = (query, {
  onComplete,
  onError,
  variables = empty$1,
  lazy = false
} = {}) => {
  const engine = useDataEngine();
  const [theQuery] = useStaticInput(query, {
    warn: true,
    name: 'query'
  });
  const execute = useCallback(options => engine.query(theQuery, options), [engine, theQuery]);
  const {
    refetch,
    called,
    loading,
    error,
    data
  } = useQueryExecutor({
    execute,
    variables,
    singular: true,
    immediate: !lazy,
    onComplete,
    onError
  });
  return {
    engine,
    refetch,
    called,
    loading,
    error,
    data
  };
};

const DataQuery = ({
  query,
  onComplete,
  onError,
  variables,
  lazy,
  children
}) => {
  const queryState = useDataQuery(query, {
    onComplete,
    onError,
    variables,
    lazy
  });
  return children(queryState);
};

var Provider = function Provider(_ref) {
  var config = _ref.config,
      children = _ref.children;
  return React.createElement(ConfigProvider, {
    config: config
  }, React.createElement(DataProvider, null, children));
};
Provider.displayName = 'DHIS2RuntimeProvider';

export { CustomDataProvider, DataMutation, DataProvider, DataQuery, Provider, useConfig, useDataEngine, useDataMutation, useDataQuery };
